# 需求文档

## 简介

本功能为多人在线飞机游戏实现客户端与服务器之间的玩家状态同步机制。当前系统存在三个核心问题：客户端无法识别自己的玩家 ID、缺乏管理多个玩家实体的数据结构、以及渲染循环只绘制本地玩家。本功能将通过扩展网络协议、引入实体管理容器和改进渲染逻辑来解决这些问题，使多个玩家能够在同一游戏世界中看到彼此并进行交互。

## 术语表

- **客户端 (Client)**: 运行在玩家本地的游戏程序，负责接收输入、渲染画面和与服务器通信
- **服务器 (Server)**: 管理游戏世界状态的中心程序，接收所有客户端输入并广播游戏快照
- **玩家 ID (Player_ID)**: 服务器分配给每个连接客户端的唯一整数标识符
- **游戏快照 (GameSnapshot)**: 包含所有玩家当前状态的 Protobuf 消息，由服务器定期广播
- **登录响应包 (LoginResponse)**: 服务器在客户端连接成功后发送的首个消息，包含分配的玩家 ID
- **实体容器 (Entity_Container)**: 客户端用于存储其他玩家数据的数据结构（如 std::map<int, PlayerData>）
- **本地玩家 (Local_Player)**: 当前客户端控制的玩家实体
- **远程玩家 (Remote_Player)**: 其他客户端控制的玩家实体
- **PlayerData**: 存储单个玩家状态的数据结构，包含位置、角度等信息
- **渲染循环 (Render_Loop)**: 客户端每帧执行的绘制逻辑，负责将游戏状态转换为屏幕图像

## 需求

### 需求 1: 客户端身份识别

**用户故事:** 作为客户端程序，我需要知道服务器分配给我的玩家 ID，以便区分本地玩家和远程玩家的数据。

#### 验收标准

1. WHEN 客户端成功连接到服务器 THEN 服务器 SHALL 立即发送一个登录响应包
2. THE 登录响应包 SHALL 包含服务器分配的唯一玩家 ID
3. WHEN 客户端接收到登录响应包 THEN 客户端 SHALL 存储该玩家 ID 作为本地玩家标识
4. WHEN 客户端接收到游戏快照 THEN 客户端 SHALL 使用存储的玩家 ID 来识别哪个 PlayerState 属于本地玩家
5. FOR ALL 游戏快照中的 PlayerState，IF PlayerState.id 不等于本地玩家 ID THEN 客户端 SHALL 将其识别为远程玩家

### 需求 2: 协议扩展

**用户故事:** 作为开发者，我需要扩展网络协议以支持登录响应消息，以便服务器能够向客户端传递玩家 ID。

#### 验收标准

1. THE game.proto 文件 SHALL 定义一个新的 LoginResponse 消息类型
2. THE LoginResponse 消息 SHALL 包含一个 int32 类型的 player_id 字段
3. WHEN 服务器接受新的客户端连接 THEN 服务器 SHALL 分配一个唯一的玩家 ID
4. WHEN 服务器分配玩家 ID 后 THEN 服务器 SHALL 序列化 LoginResponse 消息并发送给该客户端
5. THE 服务器 SHALL 在发送任何 GameSnapshot 消息之前发送 LoginResponse 消息

### 需求 3: 多玩家实体管理

**用户故事:** 作为客户端程序，我需要存储和管理所有远程玩家的状态数据，以便在游戏世界中表示他们。

#### 验收标准

1. THE 客户端 SHALL 维护一个实体容器来存储远程玩家数据
2. THE 实体容器 SHALL 使用玩家 ID 作为键，PlayerData 作为值
3. WHEN 客户端接收到游戏快照 THEN 客户端 SHALL 遍历快照中的所有 PlayerState
4. FOR ALL PlayerState，IF PlayerState.id 不等于本地玩家 ID THEN 客户端 SHALL 更新或插入该玩家数据到实体容器
5. WHEN 游戏快照中不再包含某个玩家 ID THEN 客户端 SHALL 从实体容器中移除该玩家数据
6. THE PlayerData 结构 SHALL 至少包含位置坐标（x, y）和角度（angle）字段

### 需求 4: 多玩家渲染

**用户故事:** 作为玩家，我希望在屏幕上看到其他玩家的飞机，以便了解游戏世界中的其他参与者。

#### 验收标准

1. WHEN 渲染循环执行 THEN 客户端 SHALL 首先渲染本地玩家
2. WHEN 本地玩家渲染完成后 THEN 客户端 SHALL 遍历实体容器中的所有远程玩家
3. FOR ALL 远程玩家，THE 客户端 SHALL 在其位置坐标处绘制飞机图形
4. THE 远程玩家的飞机图形 SHALL 使用与本地玩家相同的纹理或使用不同颜色的替代图形
5. WHEN 实体容器为空 THEN 客户端 SHALL 仅渲染本地玩家
6. THE 渲染顺序 SHALL 确保所有玩家飞机都可见且不被遮挡（除非游戏逻辑要求）

### 需求 5: 状态同步一致性

**用户故事:** 作为玩家，我希望看到的其他玩家位置与服务器状态保持一致，以便游戏体验流畅且公平。

#### 验收标准

1. WHEN 客户端接收到游戏快照 THEN 客户端 SHALL 在下一个渲染帧之前更新所有玩家状态
2. THE 本地玩家位置 SHALL 由服务器广播的游戏快照决定（服务器权威）
3. WHEN 客户端发送输入到服务器 THEN 客户端 SHALL 继续使用服务器返回的位置而非本地预测
4. FOR ALL 远程玩家，THE 客户端 SHALL 直接使用游戏快照中的位置数据而不进行插值或预测
5. WHEN 网络延迟导致游戏快照延迟到达 THEN 客户端 SHALL 使用最新接收到的快照数据进行渲染

### 需求 6: 玩家连接和断开处理

**用户故事:** 作为客户端程序，我需要正确处理玩家加入和离开游戏的情况，以便实体容器保持准确。

#### 验收标准

1. WHEN 新玩家加入游戏 THEN 该玩家的 PlayerState SHALL 出现在下一个游戏快照中
2. WHEN 客户端接收到包含新玩家 ID 的游戏快照 THEN 客户端 SHALL 将该玩家添加到实体容器
3. WHEN 玩家断开连接 THEN 服务器 SHALL 从游戏世界中移除该玩家
4. WHEN 游戏快照不再包含某个玩家 ID THEN 客户端 SHALL 从实体容器中移除该玩家
5. THE 客户端 SHALL 在每次接收到游戏快照后同步实体容器，确保容器内容与快照一致

### 需求 7: 网络消息处理顺序

**用户故事:** 作为客户端程序，我需要按正确的顺序处理网络消息，以便系统状态始终有效。

#### 验收标准

1. THE 客户端 SHALL 在接收到登录响应包之前不处理任何游戏快照
2. WHEN 客户端接收到登录响应包 THEN 客户端 SHALL 设置本地玩家 ID 并标记为已认证
3. WHEN 客户端已认证 THEN 客户端 SHALL 开始处理游戏快照消息
4. IF 客户端在未认证状态下接收到游戏快照 THEN 客户端 SHALL 丢弃该快照或缓存直到认证完成
5. THE 服务器 SHALL 确保登录响应包在任何游戏快照之前发送给新连接的客户端

### 需求 8: 数据结构设计

**用户故事:** 作为开发者，我需要定义清晰的数据结构来存储玩家状态，以便代码易于维护和扩展。

#### 验收标准

1. THE 客户端 SHALL 定义一个 PlayerData 结构体或类
2. THE PlayerData SHALL 包含 int id、float x、float y 和 float angle 字段
3. THE 客户端 SHALL 使用 std::map<int, PlayerData> 或等效容器作为实体容器
4. THE 实体容器 SHALL 支持通过玩家 ID 进行 O(log n) 或更快的查找操作
5. THE PlayerData SHALL 提供从 game::PlayerState Protobuf 消息构造或更新的方法
6. THE 客户端 SHALL 在 SceneMain 类中添加实体容器作为成员变量

### 需求 9: 视觉区分

**用户故事:** 作为玩家，我希望能够轻松区分自己的飞机和其他玩家的飞机，以便快速识别游戏状态。

#### 验收标准

1. THE 客户端 SHALL 为本地玩家和远程玩家使用不同的视觉表示
2. WHERE 使用相同纹理，THE 客户端 SHALL 对远程玩家应用不同的颜色调制（如使用 SDL_SetTextureColorMod）
3. WHERE 使用不同图形，THE 客户端 SHALL 为远程玩家加载和使用替代纹理或绘制简单的彩色矩形
4. THE 视觉区分 SHALL 在所有游戏场景中保持一致
5. THE 颜色或图形选择 SHALL 确保在游戏背景下具有足够的对比度和可见性
